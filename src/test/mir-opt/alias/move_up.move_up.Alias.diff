- // MIR for `move_up` before Alias
+ // MIR for `move_up` after Alias
  
  fn move_up(_1: &i32, _2: impl FnMut(&i32, i32)) -> i32 {
      debug x => _1;                       // in scope 0 at $DIR/move_up.rs:3:12: 3:13
      debug f => _2;                       // in scope 0 at $DIR/move_up.rs:3:21: 3:26
      let mut _0: i32;                     // return place in scope 0 at $DIR/move_up.rs:3:54: 3:57
      let mut _3: !;                       // in scope 0 at $DIR/move_up.rs:3:58: 7:2
      let _4: i32;                         // in scope 0 at $DIR/move_up.rs:4:9: 4:12
      let mut _5: i32;                     // in scope 0 at $DIR/move_up.rs:4:15: 4:17
      let mut _6: bool;                    // in scope 0 at $DIR/move_up.rs:4:15: 4:21
      let mut _7: bool;                    // in scope 0 at $DIR/move_up.rs:4:15: 4:21
      let mut _8: bool;                    // in scope 0 at $DIR/move_up.rs:4:15: 4:21
      let mut _9: bool;                    // in scope 0 at $DIR/move_up.rs:4:15: 4:21
      let _10: ();                         // in scope 0 at $DIR/move_up.rs:5:5: 5:14
      let mut _11: &mut impl FnMut(&i32, i32); // in scope 0 at $DIR/move_up.rs:5:5: 5:6
      let mut _12: (&i32, i32);            // in scope 0 at $DIR/move_up.rs:5:5: 5:14
      let mut _13: &i32;                   // in scope 0 at $DIR/move_up.rs:5:7: 5:8
      let mut _14: i32;                    // in scope 0 at $DIR/move_up.rs:5:10: 5:13
      let mut _15: i32;                    // in scope 0 at $DIR/move_up.rs:6:12: 6:14
      let mut _16: bool;                   // in scope 0 at $DIR/move_up.rs:6:12: 6:18
      let mut _17: bool;                   // in scope 0 at $DIR/move_up.rs:6:12: 6:18
      let mut _18: bool;                   // in scope 0 at $DIR/move_up.rs:6:12: 6:18
      let mut _19: bool;                   // in scope 0 at $DIR/move_up.rs:6:12: 6:18
      scope 1 {
          debug val => _4;                 // in scope 1 at $DIR/move_up.rs:4:9: 4:12
      }
  
      bb0: {
          StorageLive(_4);                 // scope 0 at $DIR/move_up.rs:4:9: 4:12
          StorageLive(_5);                 // scope 0 at $DIR/move_up.rs:4:15: 4:17
          _5 = (*_1);                      // scope 0 at $DIR/move_up.rs:4:15: 4:17
          _6 = Eq(const 3_i32, const 0_i32); // scope 0 at $DIR/move_up.rs:4:15: 4:21
          assert(!move _6, "attempt to divide `{}` by zero", _5) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/move_up.rs:4:15: 4:21
      }
  
      bb1: {
          _7 = Eq(const 3_i32, const -1_i32); // scope 0 at $DIR/move_up.rs:4:15: 4:21
          _8 = Eq(_5, const i32::MIN);     // scope 0 at $DIR/move_up.rs:4:15: 4:21
          _9 = BitAnd(move _7, move _8);   // scope 0 at $DIR/move_up.rs:4:15: 4:21
          assert(!move _9, "attempt to compute `{} / {}`, which would overflow", _5, const 3_i32) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/move_up.rs:4:15: 4:21
      }
  
      bb2: {
          _4 = Div(move _5, const 3_i32);  // scope 0 at $DIR/move_up.rs:4:15: 4:21
          StorageDead(_5);                 // scope 0 at $DIR/move_up.rs:4:20: 4:21
          StorageLive(_10);                // scope 1 at $DIR/move_up.rs:5:5: 5:14
          StorageLive(_11);                // scope 1 at $DIR/move_up.rs:5:5: 5:6
          _11 = &mut _2;                   // scope 1 at $DIR/move_up.rs:5:5: 5:6
          StorageLive(_12);                // scope 1 at $DIR/move_up.rs:5:5: 5:14
          StorageLive(_13);                // scope 1 at $DIR/move_up.rs:5:7: 5:8
          _13 = &(*_1);                    // scope 1 at $DIR/move_up.rs:5:7: 5:8
          StorageLive(_14);                // scope 1 at $DIR/move_up.rs:5:10: 5:13
          _14 = _4;                        // scope 1 at $DIR/move_up.rs:5:10: 5:13
          (_12.0: &i32) = move _13;        // scope 1 at $DIR/move_up.rs:5:5: 5:14
          (_12.1: i32) = move _14;         // scope 1 at $DIR/move_up.rs:5:5: 5:14
          _10 = <impl FnMut(&i32, i32) as FnMut<(&i32, i32)>>::call_mut(move _11, move _12) -> [return: bb3, unwind: bb7]; // scope 1 at $DIR/move_up.rs:5:5: 5:14
                                           // mir::Constant
                                           // + span: $DIR/move_up.rs:5:5: 5:6
                                           // + literal: Const { ty: for<'r> extern "rust-call" fn(&'r mut impl FnMut(&i32, i32), (&i32, i32)) -> <impl FnMut(&i32, i32) as FnOnce<(&i32, i32)>>::Output {<impl FnMut(&i32, i32) as FnMut<(&i32, i32)>>::call_mut}, val: Value(Scalar(<ZST>)) }
      }
  
      bb3: {
          StorageDead(_14);                // scope 1 at $DIR/move_up.rs:5:13: 5:14
          StorageDead(_13);                // scope 1 at $DIR/move_up.rs:5:13: 5:14
          StorageDead(_12);                // scope 1 at $DIR/move_up.rs:5:13: 5:14
          StorageDead(_11);                // scope 1 at $DIR/move_up.rs:5:13: 5:14
          StorageDead(_10);                // scope 1 at $DIR/move_up.rs:5:14: 5:15
          StorageLive(_15);                // scope 1 at $DIR/move_up.rs:6:12: 6:14
          _15 = (*_1);                     // scope 1 at $DIR/move_up.rs:6:12: 6:14
          _16 = Eq(const 3_i32, const 0_i32); // scope 1 at $DIR/move_up.rs:6:12: 6:18
          assert(!move _16, "attempt to divide `{}` by zero", _15) -> [success: bb4, unwind: bb7]; // scope 1 at $DIR/move_up.rs:6:12: 6:18
      }
  
      bb4: {
          _17 = Eq(const 3_i32, const -1_i32); // scope 1 at $DIR/move_up.rs:6:12: 6:18
          _18 = Eq(_15, const i32::MIN);   // scope 1 at $DIR/move_up.rs:6:12: 6:18
          _19 = BitAnd(move _17, move _18); // scope 1 at $DIR/move_up.rs:6:12: 6:18
          assert(!move _19, "attempt to compute `{} / {}`, which would overflow", _15, const 3_i32) -> [success: bb5, unwind: bb7]; // scope 1 at $DIR/move_up.rs:6:12: 6:18
      }
  
      bb5: {
          _0 = Div(move _15, const 3_i32); // scope 1 at $DIR/move_up.rs:6:12: 6:18
          StorageDead(_15);                // scope 1 at $DIR/move_up.rs:6:17: 6:18
          StorageDead(_4);                 // scope 0 at $DIR/move_up.rs:7:1: 7:2
          drop(_2) -> [return: bb6, unwind: bb8]; // scope 0 at $DIR/move_up.rs:7:1: 7:2
      }
  
      bb6: {
          return;                          // scope 0 at $DIR/move_up.rs:7:2: 7:2
      }
  
      bb7 (cleanup): {
          drop(_2) -> bb8;                 // scope 0 at $DIR/move_up.rs:7:1: 7:2
      }
  
      bb8 (cleanup): {
          resume;                          // scope 0 at $DIR/move_up.rs:3:1: 7:2
      }
  }
  
